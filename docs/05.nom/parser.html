<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Parser - Evaluating Parser Options</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body class="light">
        <!-- Provide site root to javascript -->
        <script type="text/javascript">var path_to_root = "../";</script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = 'light'; }
            document.body.className = theme;
            document.querySelector('html').className = theme + ' js';
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <ol class="chapter"><li class="affix"><a href="../01.welcome/welcome.html">Welcome</a></li><li><a href="../02.intro/introduction.html"><strong aria-hidden="true">1.</strong> Me</a></li><li><a href="../03.options/choices.html"><strong aria-hidden="true">2.</strong> Choices</a></li><li><a href="../04.baseline/iso_duration.html"><strong aria-hidden="true">3.</strong> Format</a></li><li><a href="../04.baseline/bnf.html"><strong aria-hidden="true">4.</strong> Grammar</a></li><li><a href="../04.baseline/common_code.html"><strong aria-hidden="true">5.</strong> Common Code</a></li><li><a href="../05.nom/intro.html"><strong aria-hidden="true">6.</strong> Nom</a></li><li><ol class="section"><li><a href="../05.nom/parser.html" class="active"><strong aria-hidden="true">6.1.</strong> Parser</a></li></ol></li><li><a href="../07.combine/intro.html"><strong aria-hidden="true">7.</strong> Combine</a></li><li><ol class="section"><li><a href="../07.combine/src.html"><strong aria-hidden="true">7.1.</strong> Parser</a></li></ol></li><li><a href="../06.pest/intro.html"><strong aria-hidden="true">8.</strong> Pest</a></li><li><ol class="section"><li><a href="../06.pest/src.html"><strong aria-hidden="true">8.1.</strong> Parser</a></li></ol></li><li><a href="../08.hand_rolled/intro.html"><strong aria-hidden="true">9.</strong> DIY</a></li><li><ol class="section"><li><a href="../08.hand_rolled/src.html"><strong aria-hidden="true">9.1.</strong> Parser</a></li></ol></li><li><a href="../09.perf/perf.html"><strong aria-hidden="true">10.</strong> Stats</a></li><li><a href="../10.combine/intro.html"><strong aria-hidden="true">11.</strong> Combine Revisited</a></li><li><ol class="section"><li><a href="../10.combine/src.html"><strong aria-hidden="true">11.1.</strong> Parser</a></li></ol></li></ol>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light <span class="default">(default)</span></button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Evaluating Parser Options</h1> 

                        <div class="right-buttons">
                            <a href="../print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <style>.presentation-only.not-presenting{display:none}.article-content.presenting{display:none}
</style>
<a class="header" href="#nom" id="nom"><h2>Nom</h2></a>
<!--web-only-->
<p>A good place to start when learning to use <code>nom</code> is the <code>named!</code> macro, this macro will create a function for you with a specific name and behavior. <code>named!</code> takes two arguments, the first is the function's name, this needs to include 2 generic arguments, the second is the function's body. This can be a little difficult to get used to but it isn't too much of a pain. The generic arguments provided with the name define the data type of the argument and return type respectively.</p>
<p>This is already starting to feel difficult to explain, I will re-iterate one last time that the learning curve for <code>nom</code> is pretty steep.</p>
<p>Just like with our grammar, let's start at the bottom and move up. The first <code>named!</code> entry we have in that direction is called <code>float</code>, which takes <code>CompleteStr</code> and returns <code>f32</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
named!(float&lt;CompleteStr, f32&gt;,
    map_res!(take_while1!(digit), parse_float)
);
#}</code></pre></pre>
<p>The second argument is two nested macro calls. To help understand this conceptually here is a very loose interpretation of what this might look like as a function.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn float(i: CompleteStr) -&gt; Result&lt;f32, Error&gt; {
    map_res!(take_while1!(i, digit), parse_float)
}
#}</code></pre></pre>
<p>While the above is an extreme simplification, I hope it illustrates what is going on when we use the <code>named!</code> macro.</p>
<p>To dig into the function body a little, we are using macros provided by <code>nom</code>, the first is <code>map_res!</code> which takes two arguments. The first argument is going to be a parser, this will capture some portion of the input, the second argument is a function that will take the result of the first argument's parsing and return a <code>Result</code>. The basic idea here is that we are going to map the output of a parser with the function, since the function might fail <code>map_res!</code> will convert the function's error case into a <code>nom</code> error. The first argument is <code>take_while1!</code>, another <code>nom</code> macro, this takes a function that takes 1 argument, this argument needs to be the smallest part of the input which for this would be a <code>char</code> the function then needs to return a boolean, indicating if that <code>char</code> matches what we are expecting. To flesh that our a little we should probably cover the two helper functions we are using <code>digit</code> and <code>parse_float</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn digit(c: char) -&gt; bool {
    c.is_digit(10) || c == '.'
}

fn parse_float(s: CompleteStr) -&gt; Result&lt;f32, ::std::num::ParseFloatError&gt; {
    s.parse()
}
#}</code></pre></pre>
<p>If we had the input <code>111.111H</code>, we would first use <code>take_while1</code> to pass each character to <code>digit</code>.</p>
<table><thead><tr><th> 1 </th><th> 1 </th><th> 1 </th><th> . </th><th> 1 </th><th> 1 </th><th> 1 </th><th> H </th></tr></thead><tbody>
<tr><td> ✓ </td><td> ✓ </td><td> ✓ </td><td> ✓ </td><td> ✓ </td><td> ✓ </td><td> ✓ </td><td> ✗ </td></tr>
</tbody></table>
<p>that would leave us with <code>111.111</code>, this would get passed along to <code>parse_float</code>, which would just call the <code>parse</code> method on <code>&amp;str</code>. Since the <code>parse</code> method returns a result, this would work for the requirement of <code>map_res!</code>. Now that we have a way to parse
the number part of our number + letter pairs, we can move on to the next use of <code>named!</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
named!(duration_part&lt;CompleteStr, (f32, CompleteStr)&gt;,
    do_parse!(
        value: float &gt;&gt;
        flag: take!(1) &gt;&gt;
        (value, flag)
    )
);
#}</code></pre></pre>
<p>Here we have defined <code>duration_part</code> this will take us from a <code>CompleteStr</code> to a tuple with the type <code>(f32, CompleteStr)</code>, it does this by using the <code>do_parse!</code> macro. <code>do_parse!</code> is our primary way to declare a parsing pipeline, we provide it with a list of parsers and the remaining input should be applied to them in order. Here we see the use of a couple of custom syntax items. The first is how we store a parser's result in a variable, we do that by putting the variable name and a colon before the parser (<code>value: float</code>). The second bit of custom syntax is the <code>&gt;&gt;</code> operator, this essentially means, &quot;and then&quot;. To break down what we are doing here, first we are using the <code>float</code> parser defined above, once done with that pass any remaining input on to the parser <code>take!</code>, which doesn't look at the input, just takes the number of characters requested, in our case 1.</p>
<p>At this point, you may be asking yourself &quot;why does take! need to be called but float doesn't?&quot;, that is a great question. One of the things that is hardest to get used to is that all of the <code>nom</code> macros return functions, not values. To break this down a little <code>take!</code> doesn't return the character, it returns a function that returns the character, it might look something like this.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn take(i: CompleteStr) -&gt; Result&lt;CompleteStr, Error&gt; {
    if i.len() &gt;= 1 {
        Ok(&amp;i[0..1].into())
    } else {
        Err(...)
    }
}
#}</code></pre></pre>
<p>That means the result of <code>take!</code> can be called, just like the <code>float</code>. To put it another way, we are not parsing the input, instead we are building a parser out of other parsers that will parse the input.</p>
<p>To finish the explanation of this <code>do_parse!</code>, the last step in any use of <code>do_parse!</code> we need to have a tuple, this will be the return value, for us that is the tuple of <code>(value, flag)</code> which is of type <code>(f32, CompleteStr)</code>.</p>
<p>At this point we should be able to parse a duration's smallest part. Now we need to figure out how to get that into our <code>DurationPart</code> enum. Then next item moving up the file is the helper function <code>combine_duration_part</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn combine_duration_part(value: f32, flag: CompleteStr, is_time: bool) -&gt; DurationPart {
    match *flag {
        &quot;Y&quot; =&gt; DurationPart::Years(value),
        &quot;M&quot; =&gt; if is_time {
            DurationPart::Minutes(value)
        } else {
            DurationPart::Months(value)
        },
        &quot;W&quot; =&gt; DurationPart::Weeks(value),
        &quot;D&quot; =&gt; DurationPart::Days(value),
        &quot;H&quot; =&gt; DurationPart::Hours(value),
        &quot;S&quot; =&gt; DurationPart::Seconds(value),
        _ =&gt; unreachable!()
    }
}
#}</code></pre></pre>
<p>This is going to take in the two parts the <code>f32</code> value and the <code>flag</code> as well as a third argument to indicate if an <code>M</code> means minutes or months.</p>
<p>We are going to use this as we are building the two halves. The function itself is relatively simple, just a <code>match</code> statement on the flag, matching the appropriate letter to the duration part.</p>
<p>As we move up the file, we have two more <code>named!</code> macros <code>date_part</code> and <code>time_part</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
named!(date_part&lt;CompleteStr, DurationPart&gt;,
    do_parse!(
        part: duration_part &gt;&gt;
        (combine_duration_part(part.0, part.1, false))
    )
);


named!(time_part&lt;CompleteStr, DurationPart&gt;,
    do_parse!(
        part: duration_part &gt;&gt;
        (combine_duration_part(part.0, part.1, true))
    )
);
#}</code></pre></pre>
<p>These are almost identical, essentially they use the <code>duration_part</code> to get first two arguments of <code>combine_duration_part</code>, it then provides the appropriate value for the third.</p>
<p>As we continue up we have a <code>named!</code> item to parse the <code>time_parts</code>,</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
named!(time_parts&lt;CompleteStr, Vec&lt;DurationPart&gt;&gt;,
    do_parse!(
        tag!(&quot;T&quot;) &gt;&gt;
        time_parts: many_m_n!(1, 3, time_part) &gt;&gt;
        (time_parts)
    )
);
#}</code></pre></pre>
<p>Here we have another call to <code>do_parse!</code> the first item here is is a call to <code>tag!</code>, another <code>nom</code> macro. This one simply recognizes whatever string you provide to it. In our case we are matching against the <code>T</code> that would begin the time section. It then moves on to another provided macro <code>many_m_n!</code>, this one takes three arguments, the first is the minimum number of times you expect something, the second is the maximum number of times you expect something, and the third is what you expect. In our case we expect a <code>time_part</code> at least 1 time, up to 3 times. We are going to assign the result of that to the variable <code>time_parts</code>, this value will be a <code>Vec&lt;DurationPart&gt;</code>. Since the last item in <code>do_parse!</code> needs to be a tuple, we wrap <code>time_parts</code> in parentheses.</p>
<p>Up next is another helper function, <code>combine_duration_parts</code></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn combine_duration_parts(date_parts: Option&lt;Vec&lt;DurationPart&gt;&gt;, time_parts: Option&lt;Vec&lt;DurationPart&gt;&gt;) -&gt; Duration {
    let mut duration = Duration::new();
    for part in date_parts.unwrap_or(Vec::new()).iter().chain(time_parts.unwrap_or(Vec::new()).iter()) {
        match part {
            DurationPart::Years(value) =&gt; duration.set_years(*value),
            DurationPart::Months(value) =&gt; duration.set_months(*value),
            DurationPart::Weeks(value) =&gt; duration.set_weeks(*value),
            DurationPart::Days(value) =&gt; duration.set_days(*value),
            DurationPart::Hours(value) =&gt; duration.set_hours(*value),
            DurationPart::Minutes(value) =&gt; duration.set_minutes(*value),
            DurationPart::Seconds(value) =&gt; duration.set_seconds(*value),
        }
    }
    duration
}
#}</code></pre></pre>
<p>This takes in two <code>Option&lt;Vec&lt;DurationPart&gt;&gt;</code>, the first will represent the date part and the second will represent the time part of our duration. Again this helper is mostly straight forward, it loops over both, sets of parts (if they exist) and adds them all up into a <code>Duration</code>.</p>
<p>Our last <code>named!</code> is the final step for combining all of our previous work.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
named!(duration&lt;CompleteStr, Duration&gt;,
    do_parse!(
        tag!(&quot;P&quot;) &gt;&gt;
        date_parts: opt!(many_m_n!(1, 4, date_part)) &gt;&gt;
        time_parts: opt!(time_parts) &gt;&gt;
        (combine_duration_parts(date_parts, time_parts))
    )
);
#}</code></pre></pre>
<p>Again we start with a <code>do_parse!</code>, this one begins with a <code>tag!</code> for the first letter <code>P</code>, we pass the rest on to another <code>nom</code> macor <code>opt!</code>, this converts a standard parser into a one that returns an <code>Option</code>, we pass the first one another <code>many_m_n!</code> that will generate a <code>Vec&lt;DurationPart&gt;</code> with a length from one to four, assigning the result to a variable <code>date_parts</code>. It then passes the remainder of the text to another <code>opt!</code>, this one around <code>time_parts</code> and assigns the result to a variable of the same name. Now we have the two <code>Option&lt;Vec&lt;DurationPart&gt;&gt;</code>s that we need to pass them along to the <code>combine_duration_parts</code> helper function.</p>
<p>With all that we have finally built a <code>nom</code> parser that would take in our duration string and return a <code>Duration</code>. You will notice in the <code>parse</code> function that we actually call the last <code>named!</code> item manually providing the argument. <code>nom</code> parsers always return a <code>Result</code>, the <code>Ok</code> case for this result is going to be a tuple, the first index will be the remainder of the input, the second will be a <code>Duration</code>.</p>
<p>You can find the whole parser file below.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate duration;
#[macro_use]
extern crate nom;
use nom::types::CompleteStr;
use duration::Duration;
pub fn parse(s: &amp;str) -&gt; Result&lt;Duration, String&gt; {
    let pair = duration(s.into()).map_err(|e| format!(&quot;{}&quot;, e))?;
    Ok(pair.1)
}

named!(duration&lt;CompleteStr, Duration&gt;,
    do_parse!(
        tag!(&quot;P&quot;) &gt;&gt;
        date_parts: opt!(many_m_n!(1, 4, date_part)) &gt;&gt;
        time_parts: opt!(time_parts) &gt;&gt;
        (combine_duration_parts(date_parts, time_parts))
    )
);

fn combine_duration_parts(date_parts: Option&lt;Vec&lt;DurationPart&gt;&gt;, time_parts: Option&lt;Vec&lt;DurationPart&gt;&gt;) -&gt; Duration {
    let mut duration = Duration::new();
    for part in date_parts.unwrap_or(Vec::new()).iter().chain(time_parts.unwrap_or(Vec::new()).iter()) {
        match part {
            DurationPart::Years(value) =&gt; duration.set_years(*value),
            DurationPart::Months(value) =&gt; duration.set_months(*value),
            DurationPart::Weeks(value) =&gt; duration.set_weeks(*value),
            DurationPart::Days(value) =&gt; duration.set_days(*value),
            DurationPart::Hours(value) =&gt; duration.set_hours(*value),
            DurationPart::Minutes(value) =&gt; duration.set_minutes(*value),
            DurationPart::Seconds(value) =&gt; duration.set_seconds(*value),
        }
    }
    duration
}

named!(time_parts&lt;CompleteStr, Vec&lt;DurationPart&gt;&gt;,
    do_parse!(
        tag!(&quot;T&quot;) &gt;&gt;
        time_parts: many_m_n!(1, 3, time_part) &gt;&gt;
        (time_parts)
    )
);

named!(date_part&lt;CompleteStr, DurationPart&gt;,
    do_parse!(
        part: duration_part &gt;&gt;
        (combine_duration_part(part.0, part.1, false))
    )
);


named!(time_part&lt;CompleteStr, DurationPart&gt;,
    do_parse!(
        part: duration_part &gt;&gt;
        (combine_duration_part(part.0, part.1, true))
    )
);

fn combine_duration_part(value: f32, flag: CompleteStr, is_time: bool) -&gt; DurationPart {
    match *flag {
        &quot;Y&quot; =&gt; DurationPart::Years(value),
        &quot;M&quot; =&gt; if is_time {
            DurationPart::Minutes(value)
        } else {
            DurationPart::Months(value)
        },
        &quot;W&quot; =&gt; DurationPart::Weeks(value),
        &quot;D&quot; =&gt; DurationPart::Days(value),
        &quot;H&quot; =&gt; DurationPart::Hours(value),
        &quot;S&quot; =&gt; DurationPart::Seconds(value),
        _ =&gt; unreachable!()
    }
}

named!(duration_part&lt;CompleteStr, (f32, CompleteStr)&gt;,
    do_parse!(
        value: float &gt;&gt;
        flag: take!(1) &gt;&gt;
        (value, flag)
    )
);


named!(float&lt;CompleteStr, f32&gt;,
    map_res!(take_while1!(digit), parse_float)
);

fn digit(c: char) -&gt; bool {
    c.is_digit(10) || c == '.'
}

fn parse_float(s: CompleteStr) -&gt; Result&lt;f32, ::std::num::ParseFloatError&gt; {
    s.parse()
}
#}</code></pre></pre>
<!--web-only-end-->
<!--slides-only-->
<a class="header" href="#now-for-a-demo" id="now-for-a-demo"><h1>Now for a demo!</h1></a>
<!--slides-only-end-->
<script>var PresentationMode;!function(e){e[e.Slides=0]="Slides",e[e.Web=1]="Web"}(PresentationMode||(PresentationMode={}));var PresentationModeHider=function(){function e(){var t=this;(this.queryKey="presentation_mode",this.webClass="article-content",this.preClass="presentation-only",this.mode=this.getMode(),this.setMode(),this.assignClassesViaComments(),this.mode!==PresentationMode.Slides||""!==location.pathname&&"/"!==location.pathname)||document.querySelector(".sidebar > .chapter").firstChild.firstChild.click();window.addEventListener("keyup",function(e){e.altKey&&("p"!=e.key&&"P"!=e.key&&"KeyP"!=e.code||t.toggle())})}return e.prototype.assignClassesViaComments=function(){for(var e,t=document.createNodeIterator(document.body,NodeFilter.SHOW_ELEMENT|NodeFilter.SHOW_COMMENT,null),n=this.mode===PresentationMode.Web?"not-presenting":"presenting",o=null;e=t.nextNode();)if(8===e.nodeType){var s=e.nodeValue.trim();o="web-only"===s?this.webClass:"slides-only"===s?this.preClass:null}else 1===e.nodeType&&null!==o&&e.classList.add(o,n)},e.prototype.getMode=function(){var t=localStorage.getItem(this.queryKey);if(null===t)return PresentationMode.Web;try{var e=parseInt(t);return 1<e||e<0?(console.error("presentation_mode was out of range",e),PresentationMode.Web):e}catch(e){return console.error("presentation_mode present in localStorage but value is not an integer",t,e),PresentationMode.Web}},e.prototype.setMode=function(){localStorage.setItem(this.queryKey,this.mode.toString())},e.prototype.updatePage=function(){this.updateElements(document.querySelectorAll(".presentation-only")),this.updateElements(document.querySelectorAll(".article-content"))},e.prototype.updateElements=function(e){for(var t=0;t<e.length;t++){var n=e[t];this.mode===PresentationMode.Slides?n.classList.replace("not-presenting","presenting"):n.classList.replace("presenting","not-presenting")}},e.prototype.toggle=function(){switch(this.mode){case PresentationMode.Slides:this.mode=PresentationMode.Web;break;case PresentationMode.Web:this.mode=PresentationMode.Slides}this.setMode(),this.updatePage()},e}(),___presentationModeHider=new PresentationModeHider;</script>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        
                            <a rel="prev" href="../05.nom/intro.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>
                        

                        
                            <a rel="next" href="../07.combine/intro.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>
                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                
                    <a href="../05.nom/intro.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>
                

                
                    <a href="../07.combine/intro.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
                
            </nav>

        </div>

        

        

        

        
        <script src="../elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="../clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="../highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="../book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        

    </body>
</html>
